package task_yaml

import (
	"strings"
	"testing"

	"github.com/mraron/njudge/pkg/problems"
	"github.com/spf13/afero"
	"github.com/stretchr/testify/assert"
)

func TestGen(t *testing.T) {
	tests := []struct {
		name      string
		gen       string
		testCount int
		subtasks  [][2]int
		err       error
	}{
		{"basic", `# ST: 10
1
2
# ST: 15
3
4
# ST: 20
5
6
# ST: 25
7
8
# ST: 30
9
10`, 10, [][2]int{{10, 2}, {15, 2}, {20, 2}, {25, 2}, {30, 2}}, nil},
		{"dinok", `# Generated by task-maker. Do not edit!
# tm-allow-delete
# Removing or changing the line above will prevent task-maker from touching this file again.


# Subtask 0: Examples
#ST: 0
# Testcase 0
#COPY: statement/input0.txt
# Testcase 1
#COPY: statement/input1.txt
# Testcase 2
gen_rand.py 5000 5000 10000 0.5 0.5 1

# Subtask 1: only type1
#ST: 5
# Testcase 3
gen_only1.py 100000 100000 0.5 1
# Testcase 4
gen_only1.py 100000 50000 0.5 1
# Testcase 5
gen_only1.py 100000 25000 0.5 1

# Subtask 2: N <= 4
#ST: 15
# $N <= 4
# Testcase 6
gen_rand.py 4 4 10 0.5 0.1 1
# Testcase 7
gen_rand.py 4 5 10 0.5 0.5 1
# Testcase 8
gen_rand.py 4 2 10 0.5 1.0 1
# Testcase 9
gen_rand.py 4 5 5 0.5 0.0 1
# Testcase 10
gen_rand.py 4 10 10 0.5 0.0 1
# Testcase 11
gen_rand.py 4 2 5 0.5 0.0 1

# Subtask 3: N <= 9
#ST: 10
# $N <= 9
# Testcase 12
gen_rand.py 9 5 5 0.5 0.0 1
# Testcase 13
gen_rand.py 9 15 10 0.5 0.05 1
# Testcase 14
gen_rand.py 9 15 20 0.5 0.06 1
# Testcase 15
gen_rand.py 9 15 20 0.5 0.1 1
# Testcase 16
gen_rand.py 9 10 5 0.5 0.2 1

# Subtask 4: only type 2
#ST: 35
# Testcase 17
gen_only2.py 100 10 0.0 1
# Testcase 18
gen_only2.py 1000 100 0.0 1
# Testcase 19
gen_only2.py 100000 100000 0.0 1
# Testcase 20
gen_only2.py 100000 100000 0.0 2
# Testcase 21
gen_only2.py 100 100 0.1 1
# Testcase 22
gen_only2.py 1000 1000 0.05 1
# Testcase 23
gen_only2.py 100000 100000 0.05 1

# Subtask 5: rest
#ST: 35
# Testcase 24
gen_rand.py 100000 100000 100000 0.5 0.0 1
# Testcase 25
gen_rand.py 100000 100000 200000 0.5 0.0 1
# Testcase 26
gen_rand.py 100000 100000 1000000 0.5 0.0 1
# Testcase 27
gen_rand.py 100000 100000 2000000 0.5 0.0 1
# Testcase 28
gen_rand.py 100000 100000 500000000 0.5 0.5 1
# Testcase 29
gen_rand.py 100000 100000 500000000 0.5 0.1 1
# Testcase 30
gen_rand.py 100000 100000 500000000 0.5 0.01 1
# Testcase 31
gen_rand.py 100000 100000 500000000 0.5 0.9 1
# Testcase 32
gen_rand.py 100000 100000 20000000 0.2 0.7 1
# Testcase 33
gen_rand.py 100000 100000 20000000 0.7 0.7 1
# Testcase 34
gen_rand.py 100000 100000 20000000 0.94 0.4 1
`, 35, [][2]int{{0, 3}, {5, 3}, {15, 6}, {10, 5}, {35, 7}, {35, 11}}, nil},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			testCount, subtasks, err := parseGen(strings.NewReader(test.gen))
			if err != test.err {
				t.Fatalf("err %v != %v", err, test.err)
			}

			if len(subtasks) != len(test.subtasks) {
				t.Fatalf("len(subtasks) %d != %d", len(subtasks), len(test.subtasks))
			} else {
				for ind := 0; ind < len(subtasks); ind++ {
					if subtasks[ind][0] != test.subtasks[ind][0] || subtasks[ind][1] != test.subtasks[ind][1] {
						t.Fatalf("subtasks[%d] {%d, %d} != {%d, %d}", ind, subtasks[ind][0], subtasks[ind][1], test.subtasks[ind][0], test.subtasks[ind][1])
					}
				}
			}

			if testCount != test.testCount {
				t.Fatalf("testcount %d != %d", testCount, test.testCount)
			}
		})
	}
}

func TestStatusSkeleton(t *testing.T) {
	p := Problem{
		TaskYAML: TaskYAML{
			ScoreTypeParameters: [][2]interface{}{
				{10, 2},
				{80, 5},
				{11, 10},
			},
		},
	}

	st, err := p.StatusSkeleton("")
	if err != nil {
		t.Error(err)
	}

	if len(st.Feedback[0].Testcases()) != 17 {
		t.Error("wrong no of tests")
	}

	if st.Feedback[0].MaxScore() != 101.0 {
		t.Error("wrong max score")
	}

	p = Problem{
		InputPathPattern: "%d",
		TaskYAML: TaskYAML{
			ScoreTypeParameters: [][2]interface{}{
				{10, "001|002"},
				{80, "002|003|004"},
				{12, "002|003|004|005"},
			},
		},
	}

	st, err = p.StatusSkeleton("")
	if err != nil {
		t.Error(err)
	}
	assert.Equal(t, problems.ScoringMin, st.Feedback[0].Groups[0].Scoring)
	assert.Equal(t, problems.ScoringMin, st.Feedback[0].Groups[1].Scoring)
	assert.Equal(t, problems.ScoringMin, st.Feedback[0].Groups[2].Scoring)

	assert.Equal(t, 80.0, st.Feedback[0].Groups[1].Testcases[0].MaxScore)
	assert.Equal(t, 80.0, st.Feedback[0].Groups[1].Testcases[1].MaxScore)
	assert.Equal(t, 80.0, st.Feedback[0].Groups[1].Testcases[2].MaxScore)

	if len(st.Feedback[0].Testcases()) != 9 {
		t.Error("wrong no of tests")
	}

	inputs := []string{"1", "2", "2", "3", "4", "2", "3", "4", "5"}
	for ind, tc := range st.Feedback[0].Testcases() {
		if tc.InputPath != inputs[ind] {
			t.Errorf("%s != %s input path", tc.InputPath, inputs[ind])
		}
	}

	if st.Feedback[0].MaxScore() != 102.0 {
		t.Error("wrong max score")
	}
}

func TestStatusSkeletonSum(t *testing.T) {
	taskYAML := `# General info
name: bigoutput
title: Bigus outputus

# Technical info
memory_limit: 64
time_limit: 0.5
infile: ""
outfile: ""

# Other stuff
n_input: 10
token_mode: disabled
public_testcases: all
feedback_level: full
primary_language: "hu"`
	memFS := afero.NewMemMapFs()
	if err := afero.WriteFile(memFS, "task.yaml", []byte(taskYAML), 0666); err != nil {
		t.Fatal(err)
	}
	if err := memFS.Mkdir("statement", 0666); err != nil {
		t.Fatal(err)
	}
	if err := afero.WriteFile(memFS, "statement/statement.pdf", []byte("this is a pdf"), 0666); err != nil {
		t.Fatal(err)
	}

	p, err := Parser(memFS, "./")
	if err != nil {
		t.Fatal(err)
	}

	st, err := p.StatusSkeleton("")
	if err != nil {
		t.Fatal(err)
	}

	for _, tc := range st.Feedback[0].Testcases() {
		assert.Equal(t, tc.MaxScore, 10.0)
	}
	assert.Equal(t, len(st.Feedback[0].Groups), 1)
	assert.Equal(t, st.Feedback[0].Groups[0].Scoring, problems.ScoringSum)
}
