// Code generated by mockery v2.28.1. DO NOT EDIT.

package problems

import (
	language "github.com/mraron/njudge/pkg/language"
	mock "github.com/stretchr/testify/mock"

	problems "github.com/mraron/njudge/pkg/problems"
)

// Judgeable is an autogenerated mock type for the Judgeable type
type Judgeable struct {
	mock.Mock
}

type Judgeable_Expecter struct {
	mock *mock.Mock
}

func (_m *Judgeable) EXPECT() *Judgeable_Expecter {
	return &Judgeable_Expecter{mock: &_m.Mock}
}

// Checker provides a mock function with given fields:
func (_m *Judgeable) Checker() problems.Checker {
	ret := _m.Called()

	var r0 problems.Checker
	if rf, ok := ret.Get(0).(func() problems.Checker); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(problems.Checker)
		}
	}

	return r0
}

// Judgeable_Checker_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Checker'
type Judgeable_Checker_Call struct {
	*mock.Call
}

// Checker is a helper method to define mock.On call
func (_e *Judgeable_Expecter) Checker() *Judgeable_Checker_Call {
	return &Judgeable_Checker_Call{Call: _e.mock.On("Checker")}
}

func (_c *Judgeable_Checker_Call) Run(run func()) *Judgeable_Checker_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Judgeable_Checker_Call) Return(_a0 problems.Checker) *Judgeable_Checker_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Judgeable_Checker_Call) RunAndReturn(run func() problems.Checker) *Judgeable_Checker_Call {
	_c.Call.Return(run)
	return _c
}

// Files provides a mock function with given fields:
func (_m *Judgeable) Files() []problems.File {
	ret := _m.Called()

	var r0 []problems.File
	if rf, ok := ret.Get(0).(func() []problems.File); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]problems.File)
		}
	}

	return r0
}

// Judgeable_Files_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Files'
type Judgeable_Files_Call struct {
	*mock.Call
}

// Files is a helper method to define mock.On call
func (_e *Judgeable_Expecter) Files() *Judgeable_Files_Call {
	return &Judgeable_Files_Call{Call: _e.mock.On("Files")}
}

func (_c *Judgeable_Files_Call) Run(run func()) *Judgeable_Files_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Judgeable_Files_Call) Return(_a0 []problems.File) *Judgeable_Files_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Judgeable_Files_Call) RunAndReturn(run func() []problems.File) *Judgeable_Files_Call {
	_c.Call.Return(run)
	return _c
}

// GetTaskType provides a mock function with given fields:
func (_m *Judgeable) GetTaskType() problems.TaskType {
	ret := _m.Called()

	var r0 problems.TaskType
	if rf, ok := ret.Get(0).(func() problems.TaskType); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(problems.TaskType)
		}
	}

	return r0
}

// Judgeable_GetTaskType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTaskType'
type Judgeable_GetTaskType_Call struct {
	*mock.Call
}

// GetTaskType is a helper method to define mock.On call
func (_e *Judgeable_Expecter) GetTaskType() *Judgeable_GetTaskType_Call {
	return &Judgeable_GetTaskType_Call{Call: _e.mock.On("GetTaskType")}
}

func (_c *Judgeable_GetTaskType_Call) Run(run func()) *Judgeable_GetTaskType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Judgeable_GetTaskType_Call) Return(_a0 problems.TaskType) *Judgeable_GetTaskType_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Judgeable_GetTaskType_Call) RunAndReturn(run func() problems.TaskType) *Judgeable_GetTaskType_Call {
	_c.Call.Return(run)
	return _c
}

// InputOutputFiles provides a mock function with given fields:
func (_m *Judgeable) InputOutputFiles() (string, string) {
	ret := _m.Called()

	var r0 string
	var r1 string
	if rf, ok := ret.Get(0).(func() (string, string)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func() string); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(string)
	}

	return r0, r1
}

// Judgeable_InputOutputFiles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InputOutputFiles'
type Judgeable_InputOutputFiles_Call struct {
	*mock.Call
}

// InputOutputFiles is a helper method to define mock.On call
func (_e *Judgeable_Expecter) InputOutputFiles() *Judgeable_InputOutputFiles_Call {
	return &Judgeable_InputOutputFiles_Call{Call: _e.mock.On("InputOutputFiles")}
}

func (_c *Judgeable_InputOutputFiles_Call) Run(run func()) *Judgeable_InputOutputFiles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Judgeable_InputOutputFiles_Call) Return(_a0 string, _a1 string) *Judgeable_InputOutputFiles_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Judgeable_InputOutputFiles_Call) RunAndReturn(run func() (string, string)) *Judgeable_InputOutputFiles_Call {
	_c.Call.Return(run)
	return _c
}

// Languages provides a mock function with given fields:
func (_m *Judgeable) Languages() []language.Language {
	ret := _m.Called()

	var r0 []language.Language
	if rf, ok := ret.Get(0).(func() []language.Language); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]language.Language)
		}
	}

	return r0
}

// Judgeable_Languages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Languages'
type Judgeable_Languages_Call struct {
	*mock.Call
}

// Languages is a helper method to define mock.On call
func (_e *Judgeable_Expecter) Languages() *Judgeable_Languages_Call {
	return &Judgeable_Languages_Call{Call: _e.mock.On("Languages")}
}

func (_c *Judgeable_Languages_Call) Run(run func()) *Judgeable_Languages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Judgeable_Languages_Call) Return(_a0 []language.Language) *Judgeable_Languages_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Judgeable_Languages_Call) RunAndReturn(run func() []language.Language) *Judgeable_Languages_Call {
	_c.Call.Return(run)
	return _c
}

// MemoryLimit provides a mock function with given fields:
func (_m *Judgeable) MemoryLimit() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// Judgeable_MemoryLimit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MemoryLimit'
type Judgeable_MemoryLimit_Call struct {
	*mock.Call
}

// MemoryLimit is a helper method to define mock.On call
func (_e *Judgeable_Expecter) MemoryLimit() *Judgeable_MemoryLimit_Call {
	return &Judgeable_MemoryLimit_Call{Call: _e.mock.On("MemoryLimit")}
}

func (_c *Judgeable_MemoryLimit_Call) Run(run func()) *Judgeable_MemoryLimit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Judgeable_MemoryLimit_Call) Return(_a0 int) *Judgeable_MemoryLimit_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Judgeable_MemoryLimit_Call) RunAndReturn(run func() int) *Judgeable_MemoryLimit_Call {
	_c.Call.Return(run)
	return _c
}

// StatusSkeleton provides a mock function with given fields: testset
func (_m *Judgeable) StatusSkeleton(testset string) (*problems.Status, error) {
	ret := _m.Called(testset)

	var r0 *problems.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*problems.Status, error)); ok {
		return rf(testset)
	}
	if rf, ok := ret.Get(0).(func(string) *problems.Status); ok {
		r0 = rf(testset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*problems.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(testset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Judgeable_StatusSkeleton_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StatusSkeleton'
type Judgeable_StatusSkeleton_Call struct {
	*mock.Call
}

// StatusSkeleton is a helper method to define mock.On call
//   - testset string
func (_e *Judgeable_Expecter) StatusSkeleton(testset interface{}) *Judgeable_StatusSkeleton_Call {
	return &Judgeable_StatusSkeleton_Call{Call: _e.mock.On("StatusSkeleton", testset)}
}

func (_c *Judgeable_StatusSkeleton_Call) Run(run func(testset string)) *Judgeable_StatusSkeleton_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Judgeable_StatusSkeleton_Call) Return(_a0 *problems.Status, _a1 error) *Judgeable_StatusSkeleton_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Judgeable_StatusSkeleton_Call) RunAndReturn(run func(string) (*problems.Status, error)) *Judgeable_StatusSkeleton_Call {
	_c.Call.Return(run)
	return _c
}

// TimeLimit provides a mock function with given fields:
func (_m *Judgeable) TimeLimit() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// Judgeable_TimeLimit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimeLimit'
type Judgeable_TimeLimit_Call struct {
	*mock.Call
}

// TimeLimit is a helper method to define mock.On call
func (_e *Judgeable_Expecter) TimeLimit() *Judgeable_TimeLimit_Call {
	return &Judgeable_TimeLimit_Call{Call: _e.mock.On("TimeLimit")}
}

func (_c *Judgeable_TimeLimit_Call) Run(run func()) *Judgeable_TimeLimit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Judgeable_TimeLimit_Call) Return(_a0 int) *Judgeable_TimeLimit_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Judgeable_TimeLimit_Call) RunAndReturn(run func() int) *Judgeable_TimeLimit_Call {
	_c.Call.Return(run)
	return _c
}

type mockConstructorTestingTNewJudgeable interface {
	mock.TestingT
	Cleanup(func())
}

// NewJudgeable creates a new instance of Judgeable. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewJudgeable(t mockConstructorTestingTNewJudgeable) *Judgeable {
	mock := &Judgeable{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
